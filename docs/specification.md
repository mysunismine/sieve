# Спецификация упрощённого проекта «Поиск+Модель»

## 1. Назначение
Приложение предназначено для локального запуска и помогает быстро получить структурированный ответ на запрос пользователя с ссылками на источники. Основной акцент делается на простоту: одно окно ввода, минимум экранов и отсутствие долговременного хранения данных.

## 2. Пользовательский поток
1. Пользователь открывает локальную HTML-страницу по адресу `http://127.0.0.1:8000/`.
2. Вводит вопрос, при необходимости указывает `top_n` (по умолчанию 5).
3. Нажимает кнопку «Спросить» и ждёт ответа.
4. Сервер выполняет поиск и обращается к OpenAI, формируя markdown-ответ со сносками `[1]`, `[2]`.
5. На странице отображаются ответ и список источников в блоках, стилизованных под интерфейс ChatGPT с браузингом; дополнительных действий (история, копирование, черновики) не требуется.

## 3. Архитектура
- **Интерфейс**: один шаблон Jinja2 с формой и секцией для отображения результата. Вёрстка простая, ориентирована на десктопный браузер и визуально повторяет паттерн ChatGPT: поле ввода, блок ответа, перечень источников.
- **API**: FastAPI предоставляет `GET /` (рендер шаблона), `GET /health` (статус) и `POST /api/ask` (основная логика).
- **Сервисы**: модуль для обращения к Google Custom Search JSON API и модуль для вызова OpenAI Responses API. Никаких дополнительных инструментов (кеш, база, очередь) не используется.
- **Конфигурация**: три переменные окружения с ключами. Дополнительные параметры (таймауты, язык) задаются константами в коде.

## 4. Потоки данных
1. Клиент отправляет форму → JavaScript (или стандартная отправка) вызывает `POST /api/ask`.
2. Сервер выполняет HTTP-запрос к Google CSE, собирает список `{title, url, snippet}`.
3. Затем делает вызов OpenAI Responses API с исходным вопросом и полученными результатами.
4. Ответ модели преобразуется в markdown, а также составляется массив `citations`.
5. Итог возвращается клиенту и отображается на странице.

## 5. Данные
- Постоянное хранилище отсутствует.
- История запросов, пользовательские настройки и авторизация не реализуются.
- Логи ограничены стандартным выводом FastAPI.

## 6. Нефункциональные требования
- Приложение запускается командой `uvicorn src.vibechecker.api.main:app --reload` (при наличии виртуального окружения и зависимостей).
- Работа рассчитана на одного пользователя; одновременные запросы обрабатываются последовательно.
- Ограничений по локализации нет: текст интерфейса может быть на русском, а запросы обрабатываются на двух языках без отдельной i18n-системы.
- Автотесты, покрытия и метрики отсутствуют; проверка выполняется вручную.

## 7. Зависимости
- Python 3.11+, FastAPI, `httpx`, Jinja2, pydantic.
- Внешние сервисы: Google Custom Search JSON API (необходимы `GOOGLE_API_KEY`, `GOOGLE_CSE_ID`) и OpenAI Responses API (`OPENAI_API_KEY`).
- Интернет-доступ требуется только для выполнения запросов к внешним API во время работы.

## 8. Ограничения и риски
- При отсутствии квоты Google или OpenAI сервис возвращает сообщение об ошибке; дополнительных обходных путей нет.
- Ответы не кэшируются, поэтому при повторных запросах используются новые вызовы.
- Отсутствуют механизмы авторизации и разграничения доступа, что приемлемо для локального сценария.

## 9. Приёмочные критерии
- `GET /health` возвращает статус `ok`.
- `POST /api/ask` с валидным вопросом выдаёт ответ и не менее одной цитаты (если Google вернул результаты).
- При сетевой ошибке пользователь получает понятное уведомление на странице, сервер остаётся доступным.
