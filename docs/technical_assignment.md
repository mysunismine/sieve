# Техническое задание на облегчённый сервис «Поиск+Модель»

## 1. Цель
Создать локальный инструмент, который по пользовательскому запросу обращается к Google Programmable Search Engine, передаёт результаты в OpenAI Responses API и возвращает краткий ответ с сносками на источники. Решение предназначено для одиночного использования на локальной машине и не предполагает высокой нагрузки.

## 2. Объём работ
- Реализовать компактное FastAPI-приложение с единственным рабочим эндпоинтом `/api/ask` и диагностическим `/health`.
- Настроить обращения к Google Custom Search JSON API и OpenAI Responses API без дополнительных инструментов и кешей.
- Предоставить простую HTML-страницу с текстовым полем и областью ответа, визуально напоминающую выдачу ChatGPT с браузингом: текст ответа, нумерованные ссылки, блок источников.
- Обновить документацию по локальному запуску (через Python или `uvicorn`).

## 3. Функциональные требования
- Принимать запрос пользователя (RU/EN) и необязательное число результатов `top_n` (по умолчанию 5).
- Выполнять веб-поиск и передавать заголовок, ссылку и сниппет каждого результата в модель.
- Возвращать структуру `{answer_markdown, citations[]}`; подсчёт токенов и расширенные метаданные не требуются.
- Отображать ответ, сноски `[n]` и компактный список источников на локальной HTML-странице в стиле ChatGPT browse.
- В случае ошибки внешних API возвращать понятное сообщение и текстовую пометку, что поиск недоступен.

## 4. Нефункциональные требования
- Приложение запускается локально одной командой без Docker и сложных зависимостей.
- Внешние вызовы выполняются последовательно; дополнительных оптимизаций производительности не требуется.
- Логирование ограничено короткими сообщениями об ошибках и успешных обращениях.
- Автоматические тесты, кеширование и метрики на данном этапе не внедряются.

## 5. Конфигурация
- Переменные окружения: `GOOGLE_API_KEY`, `GOOGLE_CSE_ID`, `OPENAI_API_KEY`.
- Значения по умолчанию и инструкции по настройке перечислены в `.env.example` и в документации.
- Все секреты заданы вручную перед запуском и не попадают в репозиторий.

## 6. Архитектура
- Backend: FastAPI + `httpx` для HTTP-запросов; асинхронная реализация с минимумом вспомогательных слоёв.
- UI: один шаблон Jinja2 или статический файл, обслуживаемый FastAPI, без фронтенд-фреймворков.
- Хранение данных не используется; история запросов и soft-delete исключены.

## 7. API спецификация
- `GET /health` — возвращает `{status: "ok"}` для быстрой проверки.
- `POST /api/ask` — вход: `query: str`, `top_n: Optional[int]`; выход: `answer_markdown: str`, `citations: list[{title, url, snippet}]`, `search_used: bool`.

## 8. Приёмка
- Отправка запроса из HTML-страницы или через `curl` возвращает ответ со сносками и списком источников.
- Ошибка Google API или OpenAI приводит к понятному сообщению без падения сервера.
- Документация описывает шаги локального запуска и настройки ключей.
